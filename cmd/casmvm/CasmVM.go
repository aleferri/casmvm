package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/aleferri/casmvm/pkg/opcodes"
	"github.com/aleferri/casmvm/pkg/operators"
	"github.com/aleferri/casmvm/pkg/vm"
	"github.com/aleferri/casmvm/pkg/vmio"
)

func neg(a int64) (int64, error) { return -a, nil }

//ParseLineByLine provided source file and return the vm for the program
func ParseLineByLine(sourceFile string, debugMode bool) (*vm.NaiveVM, error) {
	var programfile, programErr = os.Open(sourceFile)
	if programErr != nil {
		wnd, _ := os.Getwd()
		return nil, fmt.Errorf("Error during opening of file %s from %s\n", sourceFile, wnd)
	}

	programCode := bufio.NewReader(programfile)

	var err error
	var line string

	listings := []opcodes.Opcode{}

	line, err = programCode.ReadString('\n')
	for err == nil {
		opcodeNameIndex := strings.IndexByte(line, ' ')
		if opcodeNameIndex < 0 {
			opcodeNameIndex = len(line)
		}
		opcodeName := strings.TrimSpace(line[0:opcodeNameIndex])
		if debugMode {
			fmt.Printf("Recognized '%s'\n", opcodeName)
		}
		left := strings.TrimSpace(strings.TrimPrefix(line, opcodeName))
		args := strings.Split(left, ",")
		switch opcodeName {
		case "rpush":
			{
				listings = append(listings, opcodes.MakeRPush())
			}
		case "iconst":
			{
				val, _ := strconv.ParseInt(args[0], 10, 64)
				listings = append(listings, opcodes.MakeIConst(val))
			}
		case "branch":
			{
				val, _ := strconv.ParseInt(args[0], 10, 64)
				offset, _ := strconv.ParseInt(args[1], 10, 64)
				listings = append(listings, opcodes.MakeBranch(val, int32(offset)))
			}
		case "call":
			{
				offset, _ := strconv.ParseInt(args[0], 10, 64)
				listings = append(listings, opcodes.MakeCall(int32(offset)))
			}
		case "goto":
			{
				offset, _ := strconv.ParseInt(args[0], 10, 64)
				listings = append(listings, opcodes.MakeGoto(int32(offset)))
			}
		case "ret":
			{
				offset, _ := strconv.ParseUint(args[0], 10, 64)
				listings = append(listings, opcodes.MakeReturn(uint32(offset)))
			}
		case "rstore":
			{
				offset, _ := strconv.ParseUint(args[0], 10, 64)
				listings = append(listings, opcodes.MakeRStore(uint32(offset)))
			}
		case "rload":
			{
				offset, _ := strconv.ParseUint(args[0], 10, 64)
				listings = append(listings, opcodes.MakeRLoad(uint32(offset)))
			}
		case "sigwarn":
			{
				ref, _ := strconv.ParseUint(args[0], 10, 64)
				message := strings.Join(args[1:], ",")
				message = strings.TrimLeft(message, "\"")
				message = strings.TrimRight(message, "\"")
				listings = append(listings, opcodes.MakeSigWarning(message, uint32(ref)))
			}
		case "sigerr":
			{
				ref, _ := strconv.ParseUint(args[0], 10, 64)
				message := strings.Join(args[1:], ",")
				message = strings.TrimLeft(message, "\"")
				message = strings.TrimRight(message, "\"")
				listings = append(listings, opcodes.MakeSigError(message, uint32(ref)))
			}
		default:
			{
				if line[0] == ';' {
					goto NEXT
				}
				for str, fn := range operators.BinaryOperatorsNames {
					if opcodeName == str {
						listings = append(listings, opcodes.MakeBinaryOp(str, fn))
						goto NEXT
					}
				}
				for str, fn := range operators.UnaryOperatorsNames {
					if opcodeName == str {
						listings = append(listings, opcodes.MakeUnaryOp(str, fn))
						goto NEXT
					}
				}

				return nil, errors.New("Missing opcode " + opcodeName)
			}
		}
	NEXT:
		line, err = programCode.ReadString('\n')
	}

	return vm.MakeNaiveVM(listings, vmio.MakeVMLoggerConsole(vmio.ALL)), nil
}

func main() {
	var debugMode bool
	flag.BoolVar(&debugMode, "debug", false, "-debug=true|false")
	flag.Parse()

	fileFound := false

	for _, f := range flag.Args() {
		if !strings.HasPrefix(f, "-") {
			fileFound = true

			vm, errAsm := ParseLineByLine(f, debugMode)

			if errAsm != nil {
				fmt.Println(errAsm.Error())
				break
			}

			execErr := vm.Run(debugMode)

			if execErr != nil {
				fmt.Println(execErr.Error(), execErr.OpcodeID())
				break
			}

			if vm.EvalStack().Empty() {
				fmt.Println("No result")
			} else {
				fmt.Println(vm.EvalStack().Pop())
			}
		} else if f == "--help" {
			fmt.Println("Usage: casmvm -debug=false|true filename.csm")
			fmt.Println(
				"Specified program will be parsed and executed on the fly, the last element of the stack after the computation will be printed in the console",
			)
			fmt.Println()
			fmt.Println("This program exists to debug dumps generated by casmeleon and to be used as a library by casmeleon v2")
		}
	}

	if !fileFound {
		fmt.Println("Usage: casmvm -debug=false|true filename.csm")
	}
}
