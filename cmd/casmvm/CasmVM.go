package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/aleferri/casmvm/pkg/asm"
	"github.com/aleferri/casmvm/pkg/fast"
	"github.com/aleferri/casmvm/pkg/opcodes"
	"github.com/aleferri/casmvm/pkg/vmex"
	"github.com/aleferri/casmvm/pkg/vmio"
)

//ParseLineByLine provided source file and return the vm for the program
func ParseLineByLine(sourceFile string, debugMode bool) (*vmex.NaiveVM, error) {
	var programfile, programErr = os.Open(sourceFile)
	if programErr != nil {
		wnd, _ := os.Getwd()
		return nil, fmt.Errorf("error during opening of file %s from %s", sourceFile, wnd)
	}

	programCode := bufio.NewReader(programfile)

	keepGoing := true

	listing := []opcodes.Opcode{}
	fn := ""
	params := []string{}

	callables := []vmex.Callable{}

	for keepGoing {
		line, err := programCode.ReadString('\n')
		line = strings.TrimSpace(line)
		if line[0:2] == "fn" {
			if len(listing) > 0 {
				callables = append(callables, vmex.MakeCallable(fn, params, listing))
				listing = []opcodes.Opcode{}
			}
			tokens := strings.Fields(line)
			fn = tokens[1]
			params = []string{}
			n, _ := strconv.Atoi(tokens[2])
			for i := 0; i < n; i++ {
				params = append(params, fmt.Sprintf("%%%d", i))
			}
			line = ""
		}
		if line != "" && line[0] != ';' {
			opcode, parseError := asm.ParseOpcode(line, debugMode)
			listing = append(listing, opcode)
			if parseError != nil {
				return nil, parseError
			}
		}
		keepGoing = err == nil
	}
	callables = append(callables, vmex.MakeCallable(fn, params, listing))
	log := vmio.MakeVMLoggerConsole(vmio.ALL)

	optimized := []vmex.Callable{}
	for _, c := range callables {
		folded := fast.Fold(c)
		dce := fast.DeadCodeElimination(folded)
		optimized = append(optimized, dce)
	}

	return vmex.MakeVerboseNaiveVM(optimized, log, vmex.MakeVMFrame()), nil
}

func main() {
	var debugMode bool
	flag.BoolVar(&debugMode, "debug", false, "-debug=true|false")
	flag.Parse()

	fileFound := false

	for _, f := range flag.Args() {
		if !strings.HasPrefix(f, "-") {
			fileFound = true

			vm, errAsm := ParseLineByLine(f, debugMode)

			if errAsm != nil {
				fmt.Println(errAsm.Error())
				break
			}

			results, execErr := vm.Enter(0)

			if execErr != nil {
				fmt.Println(execErr.Error(), execErr.OpcodeID())
				break
			}

			if results.Returns().IsEmpty() {
				fmt.Println("No result")
			} else {
				fmt.Println(vm.Frame().Returns())
			}
		} else if f == "--help" {
			fmt.Println("Usage: casmvm -debug=false|true filename.csm")
			fmt.Println(
				"Specified program will be parsed and executed on the fly, the last element of the stack after the computation will be printed in the console",
			)
			fmt.Println()
			fmt.Println("This program exists to debug dumps generated by casmeleon and to be used as a library by casmeleon v2")
		}
	}

	if !fileFound {
		fmt.Println("Usage: casmvm -debug=false|true filename.csm")
	}
}
